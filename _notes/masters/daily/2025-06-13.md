aaaaaaaaaaa e
#### downsampling again
```
stride = s
kernel_size = k = 2s
padding = p = ?
L_out = floor((L_in + 2p - 2s - 2) / s + 1)
```
nvm will see empirically
ok it works if the padding is symmetrical and the same in both layers

or actually do asymmetrical padding with `nn.ZeroPad1d`?
works for `Conv1d`, but not for `ConvTranspose1d` since `padding=p` actually subtracts `p` from each side

everything's easy for even strides, for odd - hack with padding set to `max(left, right)` and `output_padding=1`

uh ok kinda works I guess lesgo
#### running
shape mismatches
getting closer and closer though